import numpy as np
from scipy import integrate, interpolate
from KCSD2D import KCSD2D
import KCSD2D_Helpers as defaults

class MoIKCSD(KCSD2D):
    """2D variant of solver for the Kernel Current Source Density method.  It is
    the implentation based on Ness et.al (2015) - which incorporates the saline
    medium around the slice.  the estimation area.  **Parameters**
    
    elec_pos : numpy array
        positions of electrodes
    sampled_pots : numpy array
        potentials measured by electrodes
    src_type : str
        basis function type ('gauss', 'step', 'gauss_lim')
    params : set, optional
        configuration parameters, that may contain the following keys:
        'sigma' : float
            space conductance of the medium
        'sigma_S' : float
            saline conductance 
        'MoI_iters' : int
            number of MoI correction terms
        'n_srcs_init' : int
            demanded number of sources
        'R_init' : float
            demanded thickness of the basis element
        'h' : float
            thickness of analyzed tissue slice
        'x_min', 'x_max', 'y_min', 'y_max' : floats
            boundaries for CSD estimation space
        'ext' : float
            length of space extension: x_min-ext ... x_max+ext
        'gdX', 'gdY' : float
            space increments in the estimation space
        'lambd' : float
            regularization parameter for ridge regression

    """
    def __init__(self, ele_pos, pots, src_type='gauss', params={}):
        defaults.KCSD2D_params['MoI_iters'] = 20 #number of iterations - Update default values.
        defaults.KCSD2D_params['sigma_S'] = 1.5 #S/m

        sigma_T = params.get('sigma', defaults.KCSD2D_params['sigma']) #Funny business!
        sigma_S = params.get('sigma_S', defaults.KCSD2D_params['sigma_S']) #Funny business! 

        self.W_TS = (sigma_T - sigma_S) / (sigma_T + sigma_S) #Eq 17, Ness (2015)
        super(MoIKCSD, self).__init__(ele_pos, pots, src_type, params)


    def b_pot_2d_cont(self, x, R, h, sigma, src_type):
        """
        FWD model functions
        Returns the value of the potential at point (x,0) generated
        by a basis source located at (0,0)
        """
        def int_pot_2D(xp, yp, x, R, h, basis_func): #This can be done better!
            """
            FWD model functions
            Returns contribution of a point xp,yp, belonging to a basis source
            support centered at (0,0) to the potential measured at (x,0),
            integrated over xp,yp gives the potential generated by a
            basis source element centered at (0,0) at point (x,0)
            **Returns**
            pot : float
            """
            y = ((x-xp)**2 + yp**2)**(0.5)
            if y < 0.00001:
                y = 0.00001
                
            #Eq 20, Ness(2015)
            correction = np.sum(np.arcsinh(h-(2*h*np.arange(self.MoI_iters))/y))
            correction += np.sum(np.arcsinh(h-(2*h*np.arange(self.MoI_iters))/y))
            pot = np.arcsinh(h/y) + (self.W_TS*correction)
            pot *= basis_func(xp, yp, [0, 0], R) #[0, 0] is origin here
            return pot
        pot, err = integrate.dblquad(int_pot_2D, -R, R, #Eq 22 kCSD by Jan,2012 
                                     lambda x: -R, 
                                     lambda x: R, 
                                     args=(x, R, h, src_type),
                                     epsrel=1e-2, epsabs=0)
        pot *= 1./(2.0*np.pi*sigma) #Potential basis functions bi_x_y
        return pot

if __name__ == '__main__':
    ele_pos = np.array([[-0.2, -0.2],[0, 0], [0, 1], [1, 0], [1,1], [0.5, 0.5],
                        [1.2, 1.2]])
    pots = np.array([[-1], [-1], [-1], [0], [0], [1], [-1.5]])
    
    params = {'gdX': 0.05, 'gdY': 0.05, 'xmin': -2.0, 'xmax': 2.0, 'ymin': -2.0,
             'ymax': 2.0}

    k = MoIKCSD(ele_pos, pots, params=params)

    print k.cross_validate()
    print k.values()
